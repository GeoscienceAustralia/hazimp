
# Copyright (C) 2012-2014 Geoscience Australia

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
 Title: vulnerability_model.py

  Author:   Ben Cooper, ben.cooper@ga.gov.au

  Description: TODO:

  Copyright 2012 by Geoscience Australia
"""

import os
import numpy

from scipy import asarray, interp, where, zeros

from core_hazimp.xml_interface import XmlLayer

DEFAULTLOSS = 0


def vuln_sets_from_xml_file(filename):
    """
    Load a GEM NRML vulnerability file in the format described in
    resources/nrml/schema/risk/vulnerability.xsd

    Args:
    :param filename: The file name of the xml file.

    :returns: A dictionary of Vulnerability Sets.
    """

    # TODO: no XSD validation is currently performed. This requires
    # lxml, which is not available in GA's runtime environment
    # currently.

    if not os.path.exists(filename):
        raise RuntimeError("No vulnerability XML was loaded." +
                           " Check file name " + filename)
    xml_node = XmlLayer(filename=filename)
    return vuln_sets_from_xml_node(xml_node)


def vuln_sets_from_xml_node(xml_node):
    """Load in the vulnerability sets from an xml node.

    :param xml_node: The root node of the vulnerability xml file.

    :returns: A dictionary of Vulnerability Sets.
    """

    vuln_sets = {}
    for xml_vuln_set in xml_node['discreteVulnerabilitySet']:
        vuln_set_id = xml_vuln_set.attributes[
            'vulnerabilitySetID']
        asset_category = xml_vuln_set.attributes['assetCategory']
        loss_category = xml_vuln_set.attributes['lossCategory']
        iml = xml_vuln_set['IML'][0]
        im_level = iml.array[0]
        intensity_measure_type = iml.attributes['IMT']
        try:
            default_loss = xml_vuln_set.attributes['defaultLoss']
        except KeyError:
            default_loss = DEFAULTLOSS

        vulnerability_functions = {}
        for func in xml_vuln_set['discreteVulnerability']:
            vuln_funct = VulnerabilityFunction.from_xml_node(func)
            vulnerability_functions[vuln_funct.function_id] = vuln_funct

        vuln_sets[vuln_set_id] = VulnerabilitySet(
            im_level,
            intensity_measure_type,
            vuln_set_id,
            asset_category,
            loss_category,
            vulnerability_functions,
            default_loss)
    return vuln_sets


class VulnerabilitySet(object):
    """
    A set of vulnerability functions for a given intensity measure
    level.  All vulnerability functions have the same intensity
    measure (x-axis) and loss category (y-axis). Each vulnerability
    function represents a class of assets, such as brick buildings
    etc.

    Methods:
    - calc_mean - return mean loss and sigma for the given function id
    - sample - return a sample for the given function id

    Constructor input:
    - intensity_measure_level - a set of points for the x axis of the mean loss
      curve (common to all functions)
    - intensity_measure_type - type of intensity measure that the intensity
      measure level specifies ('MMI' is the only supported value)
    - vulnerability_functions - a dictionary of VulnerabilityFunction objects
      where the function id is the key

    Class method:
    - from_xml - construct a Vulnerability_Set object from a NRML vulnerability
      file
    """
    # pylint: disable=R0913
    def __init__(self,
                 intensity_measure_level,
                 intensity_measure_type,
                 vulnerability_set_id,
                 asset_category,
                 loss_category,
                 vulnerability_functions,
                 default_loss):
        """
        :params intensity_measure_level: a set of points for the x axis
                of the mean loss curve (common to all functions)
        :params intensity_measure_type: type of intensity measure that the
                intensity measure level specifies e.g. MMI
        :params asset_category: The asset typology
        :params loss_category: The type of loss suffered by the asset_category
        :params vulnerability_functons: a dictionary of VulnerabilityFunction
                 objects where the function id is the key.
        """
        self.intensity_measure_level = asarray(intensity_measure_level)
        self.intensity_measure_type = intensity_measure_type
        self.vulnerability_set_id = vulnerability_set_id
        # asset_category: The asset typology
        # e.g. population, buildings
        self.asset_category = asset_category
        # loss_category: The type of loss suffered by the asset_category
        # e.g. fatalities, collapse, building damage index,
        # contents damage index
        self.loss_category = loss_category
        self.vulnerability_functions = vulnerability_functions
        self.default_loss = default_loss

    def __repr__(self):
        return ('Discrete Vulnerability Set:\n'
                '          intensity measure type: %s\n'
                '         intensity measure level: %s\n'
                'discrete vulnerability functions: %s\n'
                % (str(self.intensity_measure_type),
                   str(self.intensity_measure_level),
                   str(self.vulnerability_functions.keys())))

    def build_realised_vuln_curves(self, vulnerability_function_ids,
                                   variability_method=None):
        """
        Given a list of vulnerability_function_IDs return the
        actual vulnerability curves, as a realised vulnerabitly
        curves instance.

        Currently this just returns a mean curve.

        :parmas vulnerability_function_IDs: A list of the vuln. funct.'s.
            The list dimension is asset.
        :parmas variability_method: How the vulnerability function is sampled.

        :returns: A realised vulnerabitly curves instance.  Use this to calc
            the loss ratio.
        """
        loss_per_asset = []  # Build a list up.
        for key in vulnerability_function_ids:
            try:
                vuln_funct = self.vulnerability_functions[key]
            except KeyError:
                msg = '[%s] does not have a vulnerability curve.\n The' % key
                msg += 'Vulnerability set is %s' % self.vulnerability_set_id
                raise NotImplementedError(msg)
            loss_per_asset.append(vuln_funct.get_loss(variability_method))
        # To get dimensions (asset, loss)
        loss_per_asset = asarray(loss_per_asset)
        realised_vuln_curves = RealisedVulnerabilityCurves(
            self.intensity_measure_type,
            self.loss_category,
            self.intensity_measure_level,
            loss_per_asset,
            self.vulnerability_set_id,
            self.default_loss)
        return realised_vuln_curves

    def calc_mean(self, func_id, intensity):
        """
        A wrapper for VulnerabilityFunction.calc_mean. Lookup the
        specified vulnerability function in the set and run calc_mean
        for that function.
        """
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)

        return func.calc_mean(intensity, self.intensity_measure_level)

    def sample(self, func_id, mean, sigma):
        """
        A wrapper for VulnerabilityFunction.sample. Lookup the
        specified vulnerability function in the set and run sample for
        that function.
        """
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)

        return func.sample(mean, sigma)


def ratio_cutoff(ratio):
    """
    As VulnerabilityFunction.sample may return values outside of a ratio,
    ensure that the given ratio array is between 0 and 1 by setting values
    outside these bounds to the bounds.
    """
    # High cutoff
    ratio = where(ratio > 1.0, 1.0, ratio)
    # Low cufoff
    ratio = where(ratio < 0.0, 0.0, ratio)

    return ratio


class VulnerabilityFunction(object):
    """
    A vulnerability function defined by a specified set of points on a curve.

    Methods:
    calc_mean - return mean loss and sigma based on the given set of points
    sample - return a sample based on the specified probabilistic distribution

    """

    def __init__(self,
                 func_id,
                 mean_loss,
                 coefficient_of_variation,
                 distribution):
        """
        :param func_id: identifier for this function
        :param mean_loss: array of ratio points
        :param coefficient_of_variation: array of uncertainty points
                (shape must match shape of mean_loss)
        :param distribution: either normal ('N') or lognormal ('LN')
        :param vulnerability_set: The vulnerability set for this function.
        """

        self.function_id = func_id
        self.mean_loss = asarray(mean_loss)
        self.coefficient_of_variation = asarray(coefficient_of_variation)
        self.distribution = asarray(distribution)

    def get_loss(self, variability_method=None):
        """
        Get the actual loss for a curve.

        Currently this just returns a mean curve.

        :param variability_method: How the vulnerability function is sampled.

        :returns: The loss y-axis values, sampled using the supplied method.
        """
        if variability_method is None:
            loss_points = self.mean_loss
        if variability_method == 'mean':
            loss_points = self.mean_loss
        #if variability_method == 'random':
         #   # TODO: Fix!
          #  loss_points = self.mean_loss
        return loss_points

    def calc_mean(self, intensity):
        """
        Calculate mean loss ratio and sigma based on the specified points on
        the curve:
                        |
                        |                                +
                        |                           +
        Mean loss ratio |                     +
                        |               +
                        |            +
                        |          +
                        |         +
                        |        +
                        |       +
                        |    +
                        | +
                        +-----------------------------------
                               Intensity measure level

        For a given intensity, mean loss and sigma is determined by linearly
        interpolating the points on the curve.

        Note that sigma is calculated as cv * mean loss as cv = mean loss/sigma
        """
        mean_loss = interp(intensity,
                           self.intensity_measure_level,
                           self.mean_loss)
        cv = interp(intensity,
                    self.intensity_measure_level,
                    self.coefficient_of_variation)
        # cv = sigma / mean
        sigma = cv * mean_loss

        return (mean_loss, sigma)

    @classmethod
    def from_xml_node(cls, xml_node):
        """Load in a vulnerability function from an xml node.

        :param xml_node: The root node of the vulnerability xml file.

        :returns: A vulnerability function.
        """
        func_id = xml_node.attributes['vulnerabilityFunctionID']
        prob_dist = xml_node.attributes['probabilisticDistribution']
        loss = xml_node['lossRatio'][0].array[0]
        coeff_of_variation = xml_node['coefficientsVariation'][0].array[0]

        return cls(
            func_id,
            loss,
            coeff_of_variation,
            prob_dist)


class RealisedVulnerabilityCurves(object):
    """
    Respresents a collection of vulnerability curves associated with an
    exposure set.

    There is one vulnerability curve per asset
    """
    # pylint: disable=R0913
    def __init__(self,
                 intensity_measure_type,
                 loss_category_type,
                 intensity_measure_level,
                 loss_per_asset,
                 vulnerability_set_id,
                 default_loss):
        """

        :param intensity_measure_type: type of intensity measure that the
                intensity measure level specifies ('MMI' is the only supported
                 value).
        :param loss_category_type: Type of loss suffered by the asset_category.
        :param intensity_measure_level: a set of points for the x axis of
            the mean loss curve (common to all functions).
        :param loss_per_asset: 2D array of ratio points per asset.
                The loss dimension can be regarded as the y axis values.
                dimensions (asset, loss).
        """

        self.intensity_measure_type = intensity_measure_type
        self.loss_category_type = loss_category_type
        self.loss_per_asset = loss_per_asset

        self.intensity_measure_level = intensity_measure_level
        self.vulnerability_set_id = vulnerability_set_id
        self.default_loss = default_loss

    def look_up(self, intensity):
        """
        Given an intensity use the curve to determine the loss ratio.

        :param intensity: An array intensity measures.  Dimensions(asset, ...)

        :return: A loss value. loss_category_type describes type of loss.
        """
        # Note the dimensions after the asset are different in intensity
        # and loss_per_asset.

        loss = zeros(intensity.shape)
        assert self.loss_per_asset.shape[0] == intensity.shape[0]

        nan = numpy.isnan(intensity)
        for asset in xrange(self.loss_per_asset.shape[0]):
            loss[asset, ...] = interp(
                intensity[asset, ...],
                self.intensity_measure_level,
                self.loss_per_asset[asset, ...])
        loss[nan] = self.default_loss
        return loss


class RealisedVulnerabilityCurve(object):
    """
    Respresents realised vulnerability curve. Will be associated with an asset

    There is one vulnerability curve per asset.
    """
    # pylint: disable=R0913
    def __init__(self,
                 intensity_measure_type,
                 loss_category_type,
                 intensity_measure_level,
                 loss,
                 vulnerability_set_id,
                 default_loss):
        """

        :param intensity_measure_type: type of intensity measure that the
                intensity measure level specifies ('MMI' is the only supported
                 value).
        :param loss_category_type: Type of loss suffered by the asset_category.
        :param intensity_measure_level: a set of points for the x axis of
            the mean loss curve (common to all functions).
        :param loss: 1D array of ratio points;
            y axis values of the mean loss curve.
        """

        self.intensity_measure_type = intensity_measure_type
        self.loss_category_type = loss_category_type
        self.loss = loss

        self.intensity_measure_level = intensity_measure_level
        self.vulnerability_set_id = vulnerability_set_id
        self.default_loss = default_loss

    def look_up(self, intensity):
        """
        Given an intensity use the curve to determine the loss ratio.

        :param intensity: An array intensity measures.  Dimensions(...)
            No asset dimension though. The dimension could be multiple
            hazards for example.

        :return: A loss value. loss_category_type describes type of loss.
            Dimensions same as intensity
        """
        # Note the dimensions after the asset are different in intensity
        # and loss_per_asset.

        loss = zeros(intensity.shape)

        nan = numpy.isnan(intensity)
        loss = interp(
            intensity,
            self.intensity_measure_level,
            self.loss)
        loss[nan] = self.default_loss
        return loss
