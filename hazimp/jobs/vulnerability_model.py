
# Copyright (C) 2012-2014 Geoscience Australia

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
 Title: vulnerability_model.py

Author:   Ben Cooper, ben.cooper@ga.gov.au

Description: TODO:

Copyright 2012 by Geoscience Australia

"""

import os
import numpy
from scipy import asarray, interp, where, zeros

from hazimp.validator import Validator, NRML_SCHEMA
from hazimp.xml_interface import XmlLayer

DEFAULTLOSS = 0


def vuln_sets_from_xml_file(filenames: list) -> dict:
    """
    Load a GEM NRML vulnerability file in the format described in
    resources/nrml/schema/risk/vulnerability.xsd

    Args:
    :param filenames: The names of the xml files.

    :returns: A dictionary of Vulnerability Sets.
    """

    vulnerability_sets = {}

    for filename in filenames:
        if not os.path.exists(filename):
            raise RuntimeError(
                f'No vulnerability XML was loaded. Check file name {filename}'
            )

        validator = Validator(NRML_SCHEMA)
        validator.validate(filename)

        xml_node = XmlLayer(filename=filename)
        set_id, vulnerability_set = vuln_sets_from_xml_node(xml_node)
        vulnerability_sets[set_id] = vulnerability_set

    return vulnerability_sets


def vuln_sets_from_xml_node(xml_node):
    """
    Load in the vulnerability sets from an xml node.

    :param vulnerability_models: Dictionary to store vulnerability models.
    :param xml_node: The root node of the vulnerability xml file.

    :returns: A dictionary of Vulnerability Sets.
    """

    xml_vuln_set = xml_node['vulnerabilityModel'][0]
    vuln_set_id = xml_vuln_set.attributes['id']
    asset_category = xml_vuln_set.attributes['assetCategory']
    loss_category = xml_vuln_set.attributes['lossCategory']
    iml = xml_vuln_set['imls'][0]
    im_level = iml.array[0]
    intensity_measure_type = iml.attributes['imt']
    try:
        default_loss = xml_vuln_set.attributes['defaultLoss']
    except KeyError:
        default_loss = DEFAULTLOSS

    vulnerability_functions = {}

    for func in xml_vuln_set['vulnerabilityFunction']:
        vuln_funct = VulnerabilityFunction.from_xml_node(func)
        vulnerability_functions[vuln_funct.function_id] = vuln_funct

    return (vuln_set_id, VulnerabilitySet(
        im_level,
        intensity_measure_type,
        vuln_set_id,
        asset_category,
        loss_category,
        vulnerability_functions,
        default_loss))


class VulnerabilitySet(object):

    """
    A set of vulnerability functions for a given intensity measure
    level.  All vulnerability functions have the same intensity
    measure (x-axis) and loss category (y-axis). Each vulnerability
    function represents a class of assets, such as brick buildings
    etc.

    Methods:
    - calc_mean - return mean loss and sigma for the given function id
    - sample - return a sample for the given function id

    Constructor input:
    - intensity_measure_level - a set of points for the x axis of the mean loss
      curve (common to all functions)
    - intensity_measure_type - type of intensity measure that the intensity
      measure level specifies ('MMI' is the only supported value)
    - vulnerability_functions - a dictionary of VulnerabilityFunction objects
      where the function id is the key

    Class method:
    - from_xml - construct a Vulnerability_Set object from a NRML vulnerability
      file

    """
    # pylint: disable=R0913

    def __init__(self,
                 intensity_measure_level,
                 intensity_measure_type,
                 vulnerability_set_id,
                 asset_category,
                 loss_category,
                 vulnerability_functions,
                 default_loss):
        """
        :params intensity_measure_level: a set of points for the x axis
                of the mean loss curve (common to all functions)
        :params intensity_measure_type: type of intensity measure that the
                intensity measure level specifies e.g. MMI
        :params asset_category: The asset typology
        :params loss_category: The type of loss suffered by the asset_category
        :params vulnerability_functons: a dictionary of VulnerabilityFunction
                 objects where the function id is the key.

        """
        self.intensity_measure_level = asarray(intensity_measure_level)
        self.intensity_measure_type = intensity_measure_type
        self.vulnerability_set_id = vulnerability_set_id
        # asset_category: The asset typology
        # e.g. population, buildings
        self.asset_category = asset_category
        # loss_category: The type of loss suffered by the asset_category
        # e.g. fatalities, collapse, building damage index,
        # contents damage index
        self.loss_category = loss_category
        self.vulnerability_functions = vulnerability_functions
        self.default_loss = default_loss

    def __repr__(self):
        return ('Discrete Vulnerability Set:\n'
                '          intensity measure type: %s\n'
                '         intensity measure level: %s\n'
                'discrete vulnerability functions: %s\n'
                % (str(self.intensity_measure_type),
                   str(self.intensity_measure_level),
                   str(list(self.vulnerability_functions.keys()))))

    def build_realised_vuln_curves(self, vulnerability_function_ids,
                                   variability_method=None):
        """
        Given a list of vulnerability_function_IDs return the
        actual vulnerability curves, as a realised vulnerabitly
        curves instance.

        Currently this just returns a mean curve.

        :parmas vulnerability_function_IDs: A list of the vuln. functions.
            The list dimension is asset.
        :parmas variability_method: How the vulnerability function is sampled.

        :returns: A realised vulnerabitly curves instance.  Use this to calc
            the loss ratio.

        """
        loss_per_asset = []  # Build a list up.
        for key in vulnerability_function_ids:
            try:
                vuln_funct = self.vulnerability_functions[key]
            except KeyError:
                msg = '[%s] does not have a vulnerability curve.\n The' % key
                msg += ' vulnerability set is %s' % self.vulnerability_set_id
                raise NotImplementedError(msg)
            loss_per_asset.append(vuln_funct.get_loss(variability_method))
        # To get dimensions (asset, loss)
        loss_per_asset = asarray(loss_per_asset)
        realised_vuln_curves = RealisedVulnerabilityCurves(
            self.intensity_measure_type,
            self.loss_category,
            self.intensity_measure_level,
            loss_per_asset,
            self.vulnerability_set_id,
            self.default_loss)
        return realised_vuln_curves

    def calc_mean(self, func_id, intensity):
        """
        A wrapper for `VulnerabilityFunction.calc_mean`. Lookup the
        specified vulnerability function in the set and run `calc_mean`
        for that function.

        """
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)

        return func.calc_mean(intensity, self.intensity_measure_level)

    def sample(self, func_id, mean, sigma):
        """
        A wrapper for VulnerabilityFunction.sample. Lookup the
        specified vulnerability function in the set and run sample for
        that function.

        :param str func_id: Then name of the vulnerability function set
        :param float mean: Mean value of the selected vulnerability function
        :param float sigma: the coefficient of variation of the selected
          vunlerability function

        """
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)

        return func.sample(mean, sigma)


def ratio_cutoff(ratio):
    """
    As VulnerabilityFunction.sample may return values outside of a ratio,
    ensure that the given ratio array is between 0 and 1 by setting values
    outside these bounds to the bounds.

    :param float ratio: the value to be tested.
    :returns: 1 if ratio > 1.0, 0 if ratio < 0.0, or the value of ratio
     otherwise. 
    """
    # High cutoff
    ratio = where(ratio > 1.0, 1.0, ratio)
    # Low cufoff
    ratio = where(ratio < 0.0, 0.0, ratio)

    return ratio


class VulnerabilityFunction(object):

    """
    A vulnerability function defined by a specified set of points on a curve.

    Methods:
    calc_mean - return mean loss and sigma based on the given set of points
    sample - return a sample based on the specified probabilistic distribution

    """

    def __init__(self,
                 func_id,
                 mean_loss,
                 coefficient_of_variation,
                 distribution):
        """
        :param func_id: identifier for this function
        :param mean_loss: array of ratio points
        :param coefficient_of_variation: array of uncertainty points
                (shape must match shape of mean_loss)
        :param distribution: either normal ('N') or lognormal ('LN')
        :param vulnerability_set: The vulnerability set for this function.
        """

        self.function_id = func_id
        self.mean_loss = asarray(mean_loss)
        self.coefficient_of_variation = asarray(coefficient_of_variation)
        self.distribution = asarray(distribution)

    def get_loss(self, variability_method=None):
        """
        Get the actual loss for a curve.

        Currently this just returns a mean curve.

        :param variability_method: How the vulnerability function is sampled.

        :returns: The loss y-axis values, sampled using the supplied method.
        """
        if variability_method is None:
            loss_points = self.mean_loss
        if variability_method == 'mean':
            loss_points = self.mean_loss
        # if variability_method == 'random':
        # TODO: Fix!
        #  loss_points = self.mean_loss
        return loss_points

    def calc_mean(self, intensity):
        """
        Calculate mean loss ratio and sigma based on the specified points on
        the curve:
                        |
                        |                                +
                        |                           +
        Mean loss ratio |                     +
                        |               +
                        |            +
                        |          +
                        |         +
                        |        +
                        |       +
                        |    +
                        | +
                        +-----------------------------------
                               Intensity measure level

        For a given intensity, mean loss and sigma is determined by linearly
        interpolating the points on the curve.

        Note that sigma is calculated as cv * mean loss as cv = mean loss/sigma
        """
        mean_loss = interp(intensity,
                           self.intensity_measure_level,
                           self.mean_loss)
        cv = interp(intensity,
                    self.intensity_measure_level,
                    self.coefficient_of_variation)
        # cv = sigma / mean
        sigma = cv * mean_loss

        return (mean_loss, sigma)

    @classmethod
    def from_xml_node(cls, xml_node):
        """Load in a vulnerability function from an xml node.

        :param xml_node: The root node of the vulnerability xml file.

        :returns: A vulnerability function.
        """
        func_id = xml_node.attributes['id']
        prob_dist = xml_node.attributes['dist']
        loss = xml_node['meanLRs'][0].array[0]
        coeff_of_variation = xml_node['covLRs'][0].array[0]

        return cls(
            func_id,
            loss,
            coeff_of_variation,
            prob_dist)


class RealisedVulnerabilityCurves(object):

    """
    Respresents a collection of vulnerability curves associated with an
    exposure set.

    There is one vulnerability curve per asset
    """
    # pylint: disable=R0913

    def __init__(self,
                 intensity_measure_type,
                 loss_category_type,
                 intensity_measure_level,
                 loss_per_asset,
                 vulnerability_set_id,
                 default_loss):
        """

        :param intensity_measure_type: type of intensity measure that the
                intensity measure level specifies ('MMI' is the only supported
                 value).
        :param loss_category_type: Type of loss suffered by the asset_category.
        :param intensity_measure_level: a set of points for the x axis of
            the mean loss curve (common to all functions).
        :param loss_per_asset: 2D array of ratio points per asset.
                The loss dimension can be regarded as the y axis values.
                dimensions (asset, loss).
        """

        self.intensity_measure_type = intensity_measure_type
        self.loss_category_type = loss_category_type
        self.loss_per_asset = loss_per_asset

        self.intensity_measure_level = intensity_measure_level
        self.vulnerability_set_id = vulnerability_set_id
        self.default_loss = default_loss

    def look_up(self, intensity):
        """
        Given an intensity use the curve to determine the loss ratio.

        :param intensity: An array intensity measures.  Dimensions(asset, ...)

        :return: A loss value. loss_category_type describes type of loss.
        """
        # Note the dimensions after the asset are different in intensity
        # and loss_per_asset.

        loss = zeros(intensity.shape)
        assert self.loss_per_asset.shape[0] == intensity.shape[0]

        nan = numpy.isnan(intensity)
        for asset in range(self.loss_per_asset.shape[0]):
            loss[asset] = interp(
                intensity[asset],
                self.intensity_measure_level,
                self.loss_per_asset[asset])
        loss[nan] = self.default_loss
        return loss
